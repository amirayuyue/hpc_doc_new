"use strict";(self.webpackChunkhpc_doc_new=self.webpackChunkhpc_doc_new||[]).push([[6561],{4385:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var n=s(4848),r=s(8453);const i={title:"HPC Vocabulary and Terminology",sidebar_position:1},o=void 0,c={id:"hpcdocs/hpc-tutorials/hpc_vocab",title:"HPC Vocabulary and Terminology",description:'In this section users can find important and technical vocabulary or "jargon" related to High-Performance Computing. This page will contain the term and its definition.',source:"@site/docs/hpcdocs/hpc-tutorials/hpc_vocab.md",sourceDirName:"hpcdocs/hpc-tutorials",slug:"/hpcdocs/hpc-tutorials/hpc_vocab",permalink:"/hpc_doc_new/docs/hpcdocs/hpc-tutorials/hpc_vocab",draft:!1,unlisted:!1,editUrl:"https://github.com/amirayuyue/hpc_doc_new/docs/hpcdocs/hpc-tutorials/hpc_vocab.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"HPC Vocabulary and Terminology",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"HPC Office Hours",permalink:"/hpc_doc_new/docs/hpcdocs/hpc-tutorials/OH"},next:{title:"Slurm",permalink:"/hpc_doc_new/docs/hpcdocs/hpc-tutorials/slurm"}},a={},l=[{value:"HPC Architecture Terminology",id:"hpc-architecture-terminology",level:3},{value:"Job submission Terminology",id:"job-submission-terminology",level:3},{value:"Understanding a Serial vs Parallel Job",id:"understanding-a-serial-vs-parallel-job",level:3}];function d(e){const t={admonition:"admonition",code:"code",h3:"h3",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:'In this section users can find important and technical vocabulary or "jargon" related to High-Performance Computing. This page will contain the term and its definition.'}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"It is highly recommended that new HPC users familiarize themselves with the terminology as it will be vital for properly understanding computing resources."})}),"\n",(0,n.jsx)(t.h3,{id:"hpc-architecture-terminology",children:"HPC Architecture Terminology"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Term"}),(0,n.jsx)(t.th,{children:"Definition"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"High-Performance Computing (HPC)"}),(0,n.jsx)(t.td,{children:"A term that refers to a branch of computing that uses multiple computing resources or groups of computing resources to complete computations. HPC is much more powerful than regular computers (desktops & laptops), typically 100x more powerful. High-performance computing utilizes many computers acting as primary computing resource in the form of nodes to perform and process complex calculations at much higher speeds and scales. HPC typically is used for solving advanced and/or lengthy computational problems."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Cluster"}),(0,n.jsxs)(t.td,{children:["A Cluster, a key part of a high-performance computer, is a collection of many inter-connected computers, known as a ",(0,n.jsx)(t.code,{children:"node"}),". Typically an HPC system may have one or multiple clusters."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Node"}),(0,n.jsx)(t.td,{children:"Nodes are the processing power in a cluster. Many nodes make up a cluster. Nodes can either hold the CPU and GPU cores and one node can have many cores."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Core"}),(0,n.jsx)(t.td,{children:"A core holds the CPU component. Multiple cores make up a node."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Scheduler"}),(0,n.jsx)(t.td,{children:"A scheduler is what carries out the scheduling activity. Schedulers are often implemented to keep all computer resources busy (as in load balancing), allow multiple users to share system resources effectively, or to achieve a target quality of service."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Job"}),(0,n.jsx)(t.td,{children:"A job is the delivery method of the instructions that users send to the Cluster(then to the nodes) to execute the calculations and computations the user desires. A job is a single workload script that is submitted to the scheduler and then placed in the proper queue."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Queue"}),(0,n.jsx)(t.td,{children:"The queue is the process that jobs submitted will wait and then begin their workload on the proper allocated resources."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Interconnect"}),(0,n.jsx)(t.td,{children:"The internal network that allows the cluster nodes to communicate with one another. All nodes communicate over infiniband on Pinnacles."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Infiniband"}),(0,n.jsx)(t.td,{children:"A channel-based fabric that facilitates high-speed communications between interconnected nodes."})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"job-submission-terminology",children:"Job submission Terminology"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Term"}),(0,n.jsx)(t.th,{children:"Definition"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Partition"}),(0,n.jsxs)(t.td,{children:["Partitions are groups of nodes with common hardware specifications, designed to excel at certain types of performance. Users specify which partition they want their computations to run. As each partition holds different purposes. i.e. the ",(0,n.jsx)(t.code,{children:"gpu"})," partition has GPU processors for computations that require gpu access. Each partition has its own proper queue in the scheduler."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Serial"}),(0,n.jsxs)(t.td,{children:["Serial processing is a type of process that runs solely on ",(0,n.jsx)(t.strong,{children:"one"})," node(or cpu processor) and can only run one task at a time"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Parallel"}),(0,n.jsxs)(t.td,{children:["Parallel processing is a type of process that multiple tasks run at the same time across ",(0,n.jsx)(t.strong,{children:"many"})," nodes( or cpu processors)."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"MPI"}),(0,n.jsx)(t.td,{children:"MPI ( Message Passing Interface) a standard that describes how information should be passed between nodes and tasks. MPI is a standard, not an implementation. MPI is best used on HPC architectures optimized for parallel computing, such as those with multi-threaded CPUs. Currently the CPUs on Merced and Pinnacles do not have multithreading activated."})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"understanding-a-serial-vs-parallel-job",children:"Understanding a Serial vs Parallel Job"}),"\n",(0,n.jsx)(t.p,{children:"The choice between serial and parallel job design and implementation is critical to the speed and efficiency of the job. Below is a table that covers each job type and its respective use cases and advantages."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Use Cases"}),(0,n.jsx)(t.th,{children:"Advantages"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Serial"}),(0,n.jsx)(t.td,{children:"Simple data processing and calculations."}),(0,n.jsx)(t.td,{children:"Simplicity, Executes Linearly, Resource Efficiency"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Parallel"}),(0,n.jsx)(t.td,{children:"Big Data Processing. Intense scientific simulations"}),(0,n.jsx)(t.td,{children:"Parallel jobs efficiently utilize hardware resources by dividing a large task into smaller, independently running subtasks."})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>c});var n=s(6540);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);